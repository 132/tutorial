#+Author: [[http://leodemoura.github.io][Leonardo de Moura]]
#+HTML_HEAD: <link rel='stylesheet' href='css/tutorial.css'>
#+HTML_HEAD_EXTRA:<link rel='stylesheet' href='css/jquery-ui.css'>
#+HTML_HEAD_EXTRA:<script src=js/jquery-1.10.2.js'></script>
#+HTML_HEAD_EXTRA:<script src='js/jquery-ui.js'></script>
#+HTML_HEAD_EXTRA:<script src='js/platform.js'></script>
#+HTML_HEAD_EXTRA:<link rel='import' href='juicy-ace-editor.html'>
#+HTML_HEAD_EXTRA:<link rel='stylesheet' href='css/code.css'>
#+OPTIONS: toc:nil

* Basics: Functional Programming in Lean

Disclaimer: this document is based on the [[http://www.cis.upenn.edu/~bcpierce/sf/current/index.html][Software Foundations]] book by
Benjamin C. Pierce, Chris Casinghino, Marco Gaboardi, Michael Greenberg, Cătălin Hriţcu, Vilhelm Sjöberg, Brent Yorgey.
Their book is based on the Coq system. We just adapted it to Lean.

** Introduction

The functional programming style brings programming closer to
mathematics: If a procedure or method has no side effects, then pretty
much all you need to understand about it is how it maps inputs to
outputs — that is, you can think of its behavior as just computing a
mathematical function. This is one reason for the word "functional" in
"functional programming." This direct connection between programs and
simple mathematical objects supports both sound informal reasoning and
formal proofs of correctness.  The other sense in which functional
programming is "functional" is that it emphasizes the use of functions
(or methods) as first-class values — i.e., values that can be passed
as arguments to other functions, returned as results, stored in data
structures, etc. The recognition that functions can be treated as data
in this way enables a host of useful idioms, as we will see.  Other
common features of functional languages include algebraic data types
and pattern matching, which make it easy to construct and manipulate
rich data structures, and sophisticated polymorphic type systems that
support abstraction and code reuse. Lean shares all of these features.

** Enumerated Types

One unusual aspect of Lean is that its set of built-in features is extremely small.
For example, instead of providing the usual palette of atomic data types (booleans, integers, strings, etc.),
Lean offers an extremely powerful mechanism for defining new data types from scratch — so powerful that all
these familiar types arise as instances.
Naturally, the Lean distribution comes with a standard library providing definitions of booleans, numbers,
and many common data structures like lists. But there is nothing magic or primitive about these
library definitions: they are ordinary user code. To see how this works, let's start with a very simple example.

*** Days of the Week

The following declaration tells Lean that we are defining a new set of data values: a type.

#+BEGIN_SRC lean
inductive day :=
monday, tuesday, wednesday, thursday, friday, saturday, sunday
#+END_SRC

The type is called =day=, and its members are =monday=, =tuesday=, etc.
The second line of the definition can be read "monday is a day, tuesday is a day, etc."
Having defined =day=, we can write functions that operate on `day`s.

#+BEGIN_SRC lean
inductive day :=
monday, tuesday, wednesday, thursday, friday, saturday, sunday

-- BEGIN
definition next_weekday (d : day) : day :=
day.rec_on d
  day.tuesday
  day.wednesday
  day.thursday
  day.friday
  day.monday
  day.monday
  day.monday
-- END
#+END_SRC

One thing to note is that the argument and return types of this
function are explicitly declared. Like most functional programming
languages, Lean can often work out these types even if they are not
given explicitly -- i.e., it performs some type inference -- but we include them
to make reading easier.
Moreover, this function was defined using the recursor =day.rec_on= automatically generated by
Lean whenever we define a new inductive datatype. Lean declarations are organized
into "namespaces". We can avoid most occurrences of prefix =day= by opening the namespace =day= using the command
=open day=. Here is an alternative (and more compact) definition.

#+BEGIN_SRC lean
inductive day :=
monday, tuesday, wednesday, thursday, friday, saturday, sunday

-- BEGIN
open day

definition next_weekday d :=
day.rec_on d tuesday wednesday thursday friday monday monday monday
-- END
#+END_SRC

In the "compressed" definition above, we also omitted the argument and return types, and let
Lean figure out them.

Having defined a function, we should check that it works on some
examples. There are different ways to do this in Lean.
First, we can use the command =eval= to evaluate a compound
expression involving =next_weekday=.

#+BEGIN_SRC lean
inductive day :=
monday, tuesday, wednesday, thursday, friday, saturday, sunday

open day

definition next_weekday d :=
day.rec_on d tuesday wednesday thursday friday monday monday monday

-- BEGIN
eval next_weekday friday
--  monday
eval next_weekday (next_weekday saturday)
-- tuesday
-- END
#+END_SRC

Second, we can record what we expect the result to be in the form of a Lean example:

#+BEGIN_SRC lean
import logic

inductive day :=
monday, tuesday, wednesday, thursday, friday, saturday, sunday

open day

definition next_weekday d :=
day.rec_on d tuesday wednesday thursday friday monday monday monday

-- BEGIN
example : next_weekday (next_weekday saturday) = tuesday :=
rfl
-- END
#+END_SRC

This declaration does two things: it makes an assertion (that the
second weekday after saturday is tuesday). Having made the assertion,
we show it holds by reflexivity =rfl=.  We can justify this step by
reflexivity because the left/right hand sides of the equation are
identical, after Lean evaluates =next_weekday=.  The symbols = and
=rfl= are defined in the =logic= module, and is imported using the
command =import logic=.

*** Booleans

In a similar way, we can define the type =boolean= of booleans, with
members =true= and =false=.

#+BEGIN_SRC lean
inductive boolean :=
true, false
#+END_SRC

Although we are rolling our own booleans here for the sake of building
up everything from scratch, Lean does, of course, provide a default
implementation of the booleans in its standard library, together with
a multitude of useful functions and lemmas.

Functions over booleans can be defined in the same way as above.
We define them in the namespace =boolean=.

#+BEGIN_SRC lean
inductive boolean :=
true, false
-- BEGIN
namespace boolean

definition neg (b : boolean) : boolean :=
rec_on b false true

definition and (b1 b2 : boolean) : boolean :=
rec_on b1 b2 false

definition or (b1 b2 : boolean) : boolean :=
rec_on b1 true b2

end boolean
-- END
#+END_SRC

In the example above, we could write =rec_on= instead of =boolean.rec_on= because we
were inside the namespace =boolean=.

The following four "unit tests" constitute a complete specification --
a truth table -- for the =boolean.or= function:

#+BEGIN_SRC lean
import logic

inductive boolean :=
true, false

namespace boolean

definition neg (b : boolean) : boolean :=
rec_on b false true

definition and (b1 b2 : boolean) : boolean :=
rec_on b1 b2 false

definition or (b1 b2 : boolean) : boolean :=
rec_on b1 true b2

-- BEGIN
example : or true false = true :=
rfl

example : or false false = false :=
rfl

example : or false true = true :=
rfl

example : or true true = true :=
rfl
-- END
end boolean
#+END_SRC

The expression =sorry= can be used to fill a hole in an
incomplete definition or proof. We'll use them in the following
exercises. In general, your job in the exercises is to replace
=sorry= with real definitions or proofs.


**** _Exercise:_ =nand=

Complete the definition of the following function, then make sure that the =example=
assertions below can each be verified by Lean.
This function should return true if either or both of its inputs are false.

#+BEGIN_SRC lean
import logic

inductive boolean :=
true, false

namespace boolean
-- BEGIN
definition nand (b1 b2 : boolean) : boolean :=
/- FILL IN HERE -/ sorry
-- END
end boolean
#+END_SRC

Remove =sorry= and fill in each proof with =rfl=.

#+BEGIN_SRC lean
import logic

inductive boolean :=
true, false

namespace boolean
definition nand (b1 b2 : boolean) : boolean :=
rec_on b1 (rec_on b2 false true) true

-- BEGIN
example : nand true false = true  :=
/- FILL IN HERE -/ sorry
example : nand false false = true :=
/- FILL IN HERE -/ sorry
example : nand false true = true  :=
/- FILL IN HERE -/ sorry
example : nand true true = false  :=
/- FILL IN HERE -/ sorry
-- END
end boolean
#+END_SRC


**** _Exercise:_ =and3=

Do the same for the and3 function below.
 This function should return true when all of its inputs are true, and false otherwise.

#+BEGIN_SRC lean
import logic

inductive boolean :=
true, false

namespace boolean
-- BEGIN
definition and3 (b1 b2 b3 : boolean) : boolean :=
/- FILL IN HERE -/ sorry

example : and3 true true true = true   :=
/- FILL IN HERE -/ sorry
example : and3 false true true = false :=
/- FILL IN HERE -/ sorry
example : and3 true false true = false :=
/- FILL IN HERE -/ sorry
example : and3 true true false = false :=
/- FILL IN HERE -/ sorry
-- END
end boolean
#+END_SRC
