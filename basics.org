#+Author: [[http://leodemoura.github.io][Leonardo de Moura]]
#+HTML_HEAD: <link rel='stylesheet' href='css/tutorial.css'>
#+HTML_HEAD_EXTRA:<link rel='stylesheet' href='css/jquery-ui.css'>
#+HTML_HEAD_EXTRA:<script src=js/jquery-1.10.2.js'></script>
#+HTML_HEAD_EXTRA:<script src='js/jquery-ui.js'></script>
#+HTML_HEAD_EXTRA:<script src='js/platform.js'></script>
#+HTML_HEAD_EXTRA:<link rel='import' href='juicy-ace-editor.html'>
#+HTML_HEAD_EXTRA:<link rel='stylesheet' href='css/code.css'>
#+OPTIONS: toc:nil

* Basics: Functional Programming in Lean

Disclaimer: this document is based on the [[http://www.cis.upenn.edu/~bcpierce/sf/current/index.html][Software Foundations]] book by
Benjamin C. Pierce, Chris Casinghino, Marco Gaboardi, Michael Greenberg, Cătălin Hriţcu, Vilhelm Sjöberg, Brent Yorgey.
Their book is based on the Coq system. We just adapted it to Lean.

** Introduction

The functional programming style brings programming closer to
mathematics: If a procedure or method has no side effects, then pretty
much all you need to understand about it is how it maps inputs to
outputs — that is, you can think of its behavior as just computing a
mathematical function. This is one reason for the word "functional" in
"functional programming." This direct connection between programs and
simple mathematical objects supports both sound informal reasoning and
formal proofs of correctness.  The other sense in which functional
programming is "functional" is that it emphasizes the use of functions
(or methods) as first-class values — i.e., values that can be passed
as arguments to other functions, returned as results, stored in data
structures, etc. The recognition that functions can be treated as data
in this way enables a host of useful idioms, as we will see.  Other
common features of functional languages include algebraic data types
and pattern matching, which make it easy to construct and manipulate
rich data structures, and sophisticated polymorphic type systems that
support abstraction and code reuse. Lean shares all of these features.

** Enumerated Types

One unusual aspect of Lean is that its set of built-in features is extremely small.
For example, instead of providing the usual palette of atomic data types (booleans, integers, strings, etc.),
Lean offers an extremely powerful mechanism for defining new data types from scratch — so powerful that all
these familiar types arise as instances.
Naturally, the Lean distribution comes with a standard library providing definitions of booleans, numbers,
and many common data structures like lists. But there is nothing magic or primitive about these
library definitions: they are ordinary user code. To see how this works, let's start with a very simple example.

*** Days of the Week

The following declaration tells Lean that we are defining a new set of data values: a type.

#+BEGIN_SRC lean
inductive day :=
monday, tuesday, wednesday, thursday, friday, saturday, sunday
#+END_SRC

The type is called =day=, and its members are =monday=, =tuesday=, etc.
The second line of the definition can be read "monday is a day, tuesday is a day, etc."
Having defined =day=, we can write functions that operate on `day`s.

#+BEGIN_SRC lean
inductive day :=
monday, tuesday, wednesday, thursday, friday, saturday, sunday

definition next_weekday (d : day) : day :=
day.rec_on d
  day.tuesday
  day.wednesday
  day.thursday
  day.friday
  day.monday
  day.monday
  day.monday
#+END_SRC

One thing to note is that the argument and return types of this
function are explicitly declared. Like most functional programming
languages, Lean can often work out these types even if they are not
given explicitly -- i.e., it performs some type inference -- but we include them
to make reading easier.
Moreover, this function was defined using the recursor =day.rec_on= automatically generated by
Lean whenever we define a new inductive datatype. Lean declarations are organized
into "namespaces". We can avoid the prefix =day= by declaring =next_weekday= in the namespace =day=.
Here is an alternative (and more compact) definition.

#+BEGIN_SRC lean
inductive day :=
monday, tuesday, wednesday, thursday, friday, saturday, sunday

namespace day

  definition next_weekday d :=
  rec_on d tuesday wednesday thursday friday monday monday monday

end day
#+END_SRC

In the "compressed" definition above, we also omitted the argument and return types, and let
Lean figure out them.

Having defined a function, we should check that it works on some
examples. There are different ways to do this in Lean.
First, we can use the command =eval= to evaluate a compound
expression involving =next_weekday=.

#+BEGIN_SRC lean
inductive day :=
monday, tuesday, wednesday, thursday, friday, saturday, sunday

namespace day

  definition next_weekday d :=
  rec_on d tuesday wednesday thursday friday monday monday monday

  eval next_weekday friday
  --  monday

  eval next_weekday (next_weekday saturday)
  -- tuesday

end day
#+END_SRC

Second, we can record what we expect the result to be in the form of a Lean example:

#+BEGIN_SRC lean
import logic

inductive day :=
monday, tuesday, wednesday, thursday, friday, saturday, sunday

namespace day

  definition next_weekday d :=
  rec_on d tuesday wednesday thursday friday monday monday monday

  example : next_weekday (next_weekday saturday) = tuesday :=
  rfl

end day
#+END_SRC

This declaration does two things: it makes an assertion (that the
second weekday after saturday is tuesday). Having made the assertion,
we show it holds by reflexivity =rfl=.  We can justify this step by
reflexivity because the left/right hand sides of the equation are
identical, after Lean evaluates =next_weekday=.  The symbols = and
=rfl= are defined in the =logic= module, and is imported using the
command =import logic=.
